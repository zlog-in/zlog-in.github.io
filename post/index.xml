<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zlog</title>
    <link>/post/</link>
    <description>Recent content in Posts on Zlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Jun 2022 18:51:25 +0200</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>浅谈三种跨链技术</title>
      <link>/post/cross-chain/</link>
      <pubDate>Wed, 15 Jun 2022 18:51:25 +0200</pubDate>
      
      <guid>/post/cross-chain/</guid>
      <description>作为区块链的代表应用，比特币首次向世人展示了在没有权威授信的环境中，如何利用密码学技术实现安全可靠的点对点支付系统。在比特币之后，涌现了数量庞多的区块链项目，它们形成了具有不同特点、 针对不同应用场景的区块链网络。
每个区块链项目根据自身发展的需要，来选择合适的共识机制、数据结构、哈希函数以及签名算法。支撑起区块链蓬勃生态的技术栈组合越来越丰富，但也造成了不同项目之间的异构性，使其承载的交易数据和经济价值很难在生态内自由地流转，跨链渐渐成为行业的刚需。所谓跨链，指的是通过特定的技术方案在不同（同构或者异构）区块链之间实现安全地信息互通与价值转移，赋予其额外的互操作能力。
跨链的目的是为了在不同区块链之间进行资产的转移。例如，某用户A在比特币网络拥有10 BTC，但他想要参与以太坊生态的活动，于是他准备将手中的BTC按照当前市场价格兑换呈等价值的ETH，这就是一次典型的跨链需求。
一次成功的跨链交易拆分为以下三个步骤：
 用户的源链地址发送一笔转账交易到该链上的某接收地址 该交易的有效性通过验证，并触发目标链上的交易 目标链上的某地址向用户指定的收款地址发送一笔转账交易  为了完成上述的跨链流程，本文将介绍三种技术方案，分析它们的特点，以及讨论潜在的风险。它们分别是公证人机制、哈希时间锁和中继模式。
公证人
在行业初期，技术难点主要在于提升单链的性能，但随着PoS以及拜占庭容错算法的应用，很多区块链的峰值TPS已经能够很好地支撑起用户的交易需求，基础设施日趋完整。于是，更多的技术与金融部门开始注意到区块链所带来的交易范式的转移，参与交易的用户/机构数量和资金规模也随之提高。追逐收益的资金也频繁地在热门项目之间转移，方便、高效的跨链交易需求催生出了中心化的交易所，交易所就是最初的公证人。
这类受到信任的第三方，在跨链流程中负责跨链消息的验证和转发。根据签名方式的不同，可区分为单签和多签。单签名公证人又称作中心化公证人，通过指定单一的节点／机构为公证人角色，在交易过程中收集源链的交易数据、验证交易有效性、并通过数字签名来启动目标链的交易执行。单签模式简单，又兼具较高的处理速度。但是其缺点也显而易见，即单一节点的故障或者作恶，会导致该跨链交易系统的崩溃，使跨链服务不再可用。
!image
于是，出现了更安全可靠的多签名公证人机制来保障跨链交易。顾名思义，多签公证人机制需要指定多个节点／机构来共同完成签名授权的操作，即只有公证人中的多数节点验证了源链交易的有效性，并公布了自己的签名信息，目标链的交易才会被执行。为了避免拜占庭错误，只有大于三分之二的多数公证人采取一致行动，跨链交易的流程才能顺利进行。
哈希时间锁
以太坊的出现，第一次为智能合约提供了可靠的去中心化的执行环境，即EVM (Ethereum Virtual Machine)。在无信任的条件下，实现了资产的自动化管理，随之而来的就是如今繁荣的DeFi生态。简单来说，智能合约是由代码控制、提供读写接口实现信息交互，并根据交互信息触发特定操作的自动化协议。以太坊最了不起的创新之处在于，它实现了一个无需任何信任条件的执行环境EVM，使得任何智能合约的部署、交互与执行都不再依靠权威授信的第三方。
于是，通过智能合约部署的哈希时间锁实现了另外一种跨链技术。具体流程如下
 跨链交易的发起者选择一个保密的随机数 $S$，然后计算得到该随机数的哈希值 $h = Hash(S)$，并将$h$发送给跨链交易的响应者 发起者和响应者在各自的区块链上将待交易的资产锁在智能合约中，上锁信息为$h$，解锁密钥为随机数$S$，锁定期限分别为$T1$和$T2$，其中$T_1$必须晚于$T_2$，解锁人分别设置为对方的帐号 发起者在时刻 $T_2$范围内，通过公布$S$来获得响应者锁定在合约中的资产 ，若超时未取则合约将自动退还资产给响应者 响应者在发起者公布$S$之后，依然存在不少于$T_1-T_2$的时间窗口，去解锁属于他的资产，若超时未取则资产自动退还给发起者  !image
哈希时间锁的出现，很好地解决了跨链交易中的信任问题。只要发起者保护好私密的随机数 $S$，以及时间窗口$T_1 - T_2$足够使得响应者解锁资产，双方无需任何信任便能实现一次成功的跨链交易，可以说是实现了真正的去中心化跨链交易。
应用哈希时间锁的前提是，交易涉及的两条区块链必须支持同一种哈希函数，以及该哈希函数足够安全。前者是工程选择问题，随着以太坊的盛行，越来越多的区块链项目都会选择兼容EVM；后者是密码学问题，目前在区块链行业得到应用的哈希函数，例如SHA256 和Keccak-256，都还没有发现安全隐患。
鉴于人类在数论和量子计算的持续研究，可能在不远的未来，黑客可以利用新发明的数学工具或者计算技术来完成对当前哈希函数的攻击。到那时，密码学家们就该设计出更安全的哈希函数了。密码学大厦就是在这样的矛盾攻守之中，一点点地被构建得更加安全牢靠。
中继模式
中继模式是对跨链操作的一种抽象，易于扩展。在此抽象层上甚至可以开发出一条独立的区块链，作为跨链交易的账本。由此，在跨链交易中出现了第三条区块链，即中继链。在此模式中，存在一系列的中继节点被部署在各个区块链网络中， 负责监控、和同步该区块链的交易数据到中继链。中继链的共识节点验证跨链交易的有效性，并触发对应交易的执行。通过在每条链上部署智能合约，作为跨链操作的接口，中继模式还能将跨链作为一项基础设施，服务更多有跨链需求的项目。
!image
一次典型的中继跨链操作，如上图所示：
 用户在源链发起跨链交易请求 中继节点监测并搬运该交易信息至中继链 中继链共识节点验证交易的有效性 验证通过以后，共识节点构造对应交易 多数共识节点对交易进行签名，组成签名集合 中继节点监测共识节点产生的交易及签名 中继节点搬运该交易至目标链，等待执行  中继链的共识算法决定着跨链服务的性能和安全性，经典的拜占庭容错算法，例如PBFT，能够在大多数节点正常工作的条件下，实现较高的交易处理速度。改进版的拜占庭容错算法，例如HotStuff，进一步减少了通信复杂度，支持更大规模的节点参与共识。
中继链作为工程复杂度较高的技术方案，实现难度大，安全风险高，但是其优势也很明显。中继链搭配智能合约，能组成跨链服务网络，用一条中继链沟通多条区块链之间信息，实现更大范围的价值转移。
作为刚需，跨链解决方案必然伴随着区块链行业的发展持续改进，而跨链技术为加密资产所赋予的流动性也必然为更多优秀的区块链项目注入增长动力，彼此互惠。对跨链技术演进的持续关注，意味着在关心加密资产的流通渠道，也许可以帮助我们更好地理解交易市场的变化。</description>
    </item>
    
    <item>
      <title>RUN</title>
      <link>/post/run/</link>
      <pubDate>Fri, 08 Apr 2022 01:01:34 +0200</pubDate>
      
      <guid>/post/run/</guid>
      <description>&lt;p&gt;跑步对于我来说，是最舒服的独处方式。跑起来很简单，左脚迈过右脚，右脚迈过左脚，一步一步往前。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一個防身藥方的三味藥</title>
      <link>/post/commencement/</link>
      <pubDate>Wed, 30 Mar 2022 20:17:00 +0200</pubDate>
      
      <guid>/post/commencement/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;一篇抄自維基文庫收錄的&lt;a href=&#34;https://zh.m.wikisource.org/zh-hant/%E4%B8%80%E5%80%8B%E9%98%B2%E8%BA%AB%E8%97%A5%E6%96%B9%E7%9A%84%E4%B8%89%E5%91%B3%E8%97%A5&#34;&gt;演講稿&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>FastBFT</title>
      <link>/post/fastbft/</link>
      <pubDate>Sat, 09 Oct 2021 11:30:23 +0200</pubDate>
      
      <guid>/post/fastbft/</guid>
      <description>&lt;p&gt;一篇论文小笔记，而已。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《民权初步》序</title>
      <link>/post/rro-intro/</link>
      <pubDate>Fri, 06 Aug 2021 11:31:19 +0200</pubDate>
      
      <guid>/post/rro-intro/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近在读《罗伯特议事规则》，瞥见孙中山因此书作序言，便手录在此。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>共识系列|拜占庭将军问题</title>
      <link>/post/byz/</link>
      <pubDate>Mon, 05 Jul 2021 20:52:56 +0200</pubDate>
      
      <guid>/post/byz/</guid>
      <description>&lt;p&gt;得益于无数聪明的头脑，对于区块链行业发展的思考和探索正在朝着两个方向迈进，有人在想象并期待着区块链之上能够出现更多安全而且可靠的DAPP，为数字资产的流动赋予无与伦比的自由和速度；也有人在深刻思索着区块链之下的共识机制，审视着人类协作活动的最基础性原理，以求得一条最为直接而且可信的通往共识之路，并改变人类组织的管理模式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>可变难度下的超轻验证原理</title>
      <link>/post/flyclient02/</link>
      <pubDate>Thu, 06 May 2021 22:58:30 +0200</pubDate>
      
      <guid>/post/flyclient02/</guid>
      <description>&lt;p&gt;在前一篇文章，我们详细解释了基于不变难度的超轻节点如何验证区块的有效性以及其验证结果正确概率的模型。这个模型的前提是基于理想状态设定的，能够帮助读者更容易理解超轻节点的工作流程和其背后的数学原理，但在真实的区块链行业，基于PoW的共识算法会随着参与网络竞争的节点数量和运算能力改变而周期性调整难度目标。这意味着，节点必须检查区块的PoW是否满足难度调整函数。&lt;/p&gt;
&lt;p&gt;在本篇文章，我们将首先介绍中本聪为比特币网络设置的难度调整函数，然后用更形式化的方法为读者解释难度调整函数，最后说明在可变难度下超轻节点如何检查区块的PoW。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>超轻节点如何验证PoW有效性</title>
      <link>/post/flyclient01/</link>
      <pubDate>Fri, 12 Mar 2021 22:28:03 +0200</pubDate>
      
      <guid>/post/flyclient01/</guid>
      <description>&lt;p&gt;为了验证交易的合法性，加密货币例如比特币和以太坊，要求节点必须验证区块链的有效性。节点在接入加密货币网络之初，需要花费数小时以及相当大的磁盘空间来下载、验证和存储所有区块。然而一些客户端由于缺乏必要的资源(带宽、存储)，无法独立验证交易，必须依赖全节点。比特币和以太坊均提供了一种名为SPV客户端的方法，SPV客户端仅仅验证和保存所有的区块头。然而，仅仅保存区块头的存储要求也是随着链长的增长而线性增长。至2021年1月为止，以太坊网络的SPV客户端需要存储的区块头数据已经逼近 6 GB。对于资源更受限的 IoT 设备，其存储上限可能都无法达到上述要求。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RLP编解码规则</title>
      <link>/post/rlp/</link>
      <pubDate>Wed, 10 Mar 2021 22:15:27 +0200</pubDate>
      
      <guid>/post/rlp/</guid>
      <description>&lt;p&gt;递归式长度前缀(Recursive Length Prefix)是以太坊用来对数据进行序列化和反序列的编码规则，这里是参考以太网维基[^1]的一篇小小笔记。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>梅克尔山脉——跨链交易中超轻验证的可能性</title>
      <link>/post/mmr-intro/</link>
      <pubDate>Fri, 05 Feb 2021 22:11:59 +0200</pubDate>
      
      <guid>/post/mmr-intro/</guid>
      <description>&lt;p&gt;梅克尔树被发明的初衷，是为了给大量的数据做一个简短的声明，即使数据被拆成若干个部分保存，也能通过梅克尔树来判断最后组合起来的整体的正确性。因为如果某一部分数据被修改或者遭受损坏，最后就无法得到与之前相同的根哈希。&lt;/p&gt;
&lt;p&gt;不难理解，能够这么做的前提是已知所有的数据，才能使用梅克尔树。但在区块链领域，每一种链一直都在产生新的区块。2012年，比特币核心开发者Peter Todd遇到了类似的问题。在为一堆不停增长的数据求根哈希的时候，他需要找到一种办法来方便快捷地向梅克尔树上新增叶子节点，同时保证求取根的过程尽量简单，于是他发明了梅克尔山脉(Merkle Mountain Ranges, )——一种专为不停增长的数据整体求根哈希的结构。本文将详细介绍梅克尔山脉及其应用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Merkle Tree之二</title>
      <link>/post/merkle-tree02/</link>
      <pubDate>Thu, 14 Jan 2021 22:08:24 +0200</pubDate>
      
      <guid>/post/merkle-tree02/</guid>
      <description>&lt;p&gt;在前一篇文章里，笔者介绍了如何使用梅克尔树给一个区块里的所有交易生成一个哈希，作为树根存储在区块头，以及解释了当交易数量不足时，为什么需要引入的冗余信息来「凑齐」一棵完整二叉树，最后说明了比特币网络如何避免由于冗余信息所引起的潜在双花攻击。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Merkle Tree之一</title>
      <link>/post/merkle-tree01/</link>
      <pubDate>Mon, 11 Jan 2021 17:33:21 +0800</pubDate>
      
      <guid>/post/merkle-tree01/</guid>
      <description>&lt;p&gt;双花攻击是任何一种数字货币都需要解决的问题，如果是真实的物理货币，天然可以避免双花攻击，因为攻击者口袋里的钱币花出去了，就真实地离开了自己。而数字货币，其实是一串特殊的字符串，可以无限复制，如何使被复制的信息不再有效，就成了解决双花问题的关键。即使是中国央行推出的数字人民币系统DC/EP，也在一定程度上面临双花问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>回来</title>
      <link>/post/back-to-china2020/</link>
      <pubDate>Fri, 13 Nov 2020 11:09:25 +0100</pubDate>
      
      <guid>/post/back-to-china2020/</guid>
      <description>汉莎航班LH728在十二点左右的时候抵达停机坪，乘务在广播里面请求大家先坐在原位，不要起身拿行李。稍后一会儿，动作干练、全身防备的防疫工作者进入机舱，将具有发热、咽痛或者咳嗽的几名乘客优先带离，去做核酸检测，剩下的人按照座位号码依次离开。我在第二十排，很快就离开飞机，前往大厅领取「采样知情同意书」。在去采样实验室的路上，可见好几处红外测温仪。同样因为前额头发比较长，我还被拦下，要求把刘海撩上去，重新测。在做鼻拭子采样的时候，护士动作很温柔，较之前在法兰克福的体验，要好很多。这一次，两只鼻孔都需要采样。过程是这样的：将口罩摘下露出鼻孔，但要遮住嘴唇。脸向上自然昂起，护士姐姐用一根长长的棉签伸进鼻孔，在抵达一个较深的位置后，她提醒我自然呼吸十秒钟，同时她也缓缓旋转棉签，尽可能多地采集样本。
做完核酸检测以后，排队等待通关。疫情期间，即使是中国籍旅客，也必须走人工核验通道。海关小姊姊看了一眼我的护照，询问隔离结束以后的行程安排。如果需要离开上海的话，根据目的地的不同，在上海的隔离要求也不一样。像是江浙皖地区的人员可是实行3+11隔离政策，即上海隔离3天，然后转运回当地继续隔离11天。而我选择直接隔离满14天以后，继续在上海完成我的实习。
通关以后，来到旋转托盘处等我的行李被传送出来。在这同一个托盘上，有来自两个航班的行李，德国的LH728和国航的CA6228。大家从天涯的尽头回来，一路艰辛，此刻等待的片段，算是难得的轻松。因为我使用了一个艳红色的行李套，所以很远就能一眼看到我的旅行箱子。拿到旅行箱子，就可以彻底离开海关处了。不用多说，离开海关前，还必须做最后一次行李安检。出来以后，很快遇到工作人员询问，是本地还是离开上海？
因为我的目的地是上海松江，现在需要走到松江区设置在浦东机场的防疫小组。在工作人员的提醒下，我完成了最后一次信息提交，获得了一张机场入境旅客二维码，内容无外乎证件号码，上海居住地址，联系方式等等。这二维码将被打印出来，贴在护照的背面，以备查验。
上海各个区在机场的地铁入口附近都设立了工作区域，其实就是连成一排的桌子，后面坐着几位工作人员，负责登记旅客信息，收集护照，安排隔离酒店，然后联系大巴将旅客转运至酒店隔离。据说，酒店的分配应该是完全随机的，我们并不能提任何要求，只能等待宣布结果。而我在登记信息的时候，小哥询问隔离是希望住200块一晚，还是400块一晚？我毫不犹豫选择了前者，此趟归途，花费不菲，还是尽量节约吧。稍后赶到的另外一个男生，选择了400档，他应该是同我一样从德国回来。
登记完成以后，时间大致一点半左右。浦东机场这一套检测分流的过程，操作起来颇为迅速，几乎没有遇到排队的现象。而我目及的所有工作人员，统统着统一的防疫服，佩戴N95口罩与护目眼镜，带医用胶手套，几乎没有裸露在外的皮肤。所有人除了嗓音，身形的不同，其它的区别统统都被抹去。有个瞬间，我甚至觉得，他们像是星球大战里面的克隆人大军。另外，在这完全相同的着装之下，似乎人人都实现了某种平等。那种用来区分科层的服饰，被隐藏在洁白的防护服之下。在我们看来，对方是科长或者普通职员，已没有任何不同。
在等待约二个小时以后，终于通知我们可以登上大巴前往松江了。这一趟总共就八人去松江隔离，其中四人和我一样住在泗泾人才公寓。这应该区政府为了这片创新园区所设立的廉价酒店，是一座公共设施，价格也相当便宜。每天餐食60块，每天房费200块，隔离14天总共花费3640+120块核酸检测 = 3760块，比我之前预计的要少很多。
因为睡得早，今晚夜半醒来，发现浦东机场似乎成为了上海这次疫情的爆发中心。看到了社交网络里面乌泱泱挤在一起等待核酸检测的人们，心中难过，这件事情远远还没有结束。</description>
    </item>
    
    <item>
      <title>作用域与链接性</title>
      <link>/post/scope-linkage/</link>
      <pubDate>Thu, 29 Oct 2020 23:14:15 +0100</pubDate>
      
      <guid>/post/scope-linkage/</guid>
      <description>&lt;p&gt;这是一篇关于&lt;code&gt;C++&lt;/code&gt;变量的作用域与链接性的笔记，整理了各种相关概念以备疏忘。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>现代密码系统的安全概念与形式</title>
      <link>/post/formal-security/</link>
      <pubDate>Sun, 18 Oct 2020 21:24:07 +0200</pubDate>
      
      <guid>/post/formal-security/</guid>
      <description>&lt;p&gt;在不久之前，密码学还不能被称作一门学科，顶多是一种手艺。在古典密码学时代，密码系统的安全仅仅取决于设计者和攻击者的创造力和技巧，人们并不能证明一种密码系统的安全性究竟几何？也没有对密码系统的诸多元件有清晰而明确的定义。&lt;/p&gt;
&lt;p&gt;密码学真正成为一门系统而逻辑严密的学科，源自二战时，交战双方终于意识到通信的安全性对于战局的决定性影响力。德国佬的Enigma机器曾使盟军头痛不已，直到图灵和波兰数学家的合作才终于破译德军的军事情报信息。由战争带来的对于安全通信的需求，在战后的冷战时代未曾消减，密码学的理论研究终于大放异彩。今天，几乎所有关于密码理论的基本概念都源自那个令人不安的时代。&lt;/p&gt;
&lt;p&gt;本篇小文将介绍现代密码系统的几种安全模型，及其相互关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CBC之伪造密文</title>
      <link>/post/cbc-fake-cipher/</link>
      <pubDate>Tue, 06 Oct 2020 11:49:35 +0200</pubDate>
      
      <guid>/post/cbc-fake-cipher/</guid>
      <description>&lt;p&gt;之前的&lt;a href=&#34;https://www.zlog-in/post/cbc-padding/&#34;&gt;小文&lt;/a&gt;详细介绍了如何利用&lt;code&gt;Oracle&lt;/code&gt;实现对CBC的填充攻击，从而解出明文内容。此篇小文将解释如何利用这一对明文密文&lt;code&gt;(m,c)&lt;/code&gt;，在不知道密钥的情况下，构造一个对合法的明文密钥&lt;code&gt;(M,C)&lt;/code&gt;。这样，攻击者便能在通信双方未能察觉之下修改通信内容，以达到自己的目的。跟前文一样，此文还是以二个消息块为例。有了前文的基础，此文直接进入主题。对CBC不了解或者不够熟悉的读者，请先翻阅前文。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线性分析 FEAL4</title>
      <link>/post/feal4/</link>
      <pubDate>Thu, 01 Oct 2020 21:03:03 +0200</pubDate>
      
      <guid>/post/feal4/</guid>
      <description>&lt;p&gt;FEAL4(Fast data Encryption Algorithm)由日本密码学家清水明宏和宫口庄司于1987年在日本电信电话株式会社(NTT)任职期间提出，作为一个针对DES的替代加密方案。相比较DES被设计成硬件电路的思路，FEAL4可由纯软件实现，得益于较少的加密轮数(4轮)，其执行速度相当快。本文首先介绍FEAL4以及DES所使用的Feistel加密结构，根据FEAL4所使用的F函数，分析F输入及输出之间的线性关系。然后解释，如何利用该线性关系配合较少的明文密文对，攻击者可以快速破解密钥。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CBC填充攻击</title>
      <link>/post/cbc-padding/</link>
      <pubDate>Sat, 19 Sep 2020 20:53:58 +0200</pubDate>
      
      <guid>/post/cbc-padding/</guid>
      <description>&lt;p&gt;CBC(Cipher Block Chaining)是一种块加密，所谓块，就是一段固定长度的数据。明文，也就是待加密的数据，被分割成若干个块，然后分别加密每一个块。如果最后一个块未被填满，则需要额外的数据填充其中，然后加密。在本文首先介绍CBC加密系统的工作流程，然后就其采用的填充标准&lt;a href=&#34;https://tools.ietf.org/html/rfc2315#section-10.3&#34;&gt;PKCS#7&lt;/a&gt;详细说明一种攻击方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SOCKS5协议</title>
      <link>/post/socks5/</link>
      <pubDate>Tue, 08 Sep 2020 12:56:50 +0200</pubDate>
      
      <guid>/post/socks5/</guid>
      <description>&lt;p&gt;最近看了一下&lt;a href=&#34;https://tools.ietf.org/html/rfc1928&#34;&gt;&lt;code&gt;SOCKS5&lt;/code&gt;&lt;/a&gt;协议，一个小巧方便的代理协议，这里是一些笔记。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大数幂运算</title>
      <link>/post/exponential-large-number/</link>
      <pubDate>Tue, 25 Aug 2020 22:25:43 +0200</pubDate>
      
      <guid>/post/exponential-large-number/</guid>
      <description>幂运算(Exponentiation)又称指数运算，写作\(c= m^e \)，即\(c\)等于\(e\)个\(m\)相乘。当\(m\)或者\(e\)的数值不大的时候，可以通过重复的乘法运算来获得\(c\)。当\(m\)和\(e\)都是一个大数的时候，比如说512位长。尽管有了计算机，显然对\(m\)重复\(e\)次乘法运算的效率不高。那么该怎样快速进行大数幂运算呢？</description>
    </item>
    
    <item>
      <title>RSA填充攻击</title>
      <link>/post/rsa-padding/</link>
      <pubDate>Thu, 20 Aug 2020 10:09:33 +0200</pubDate>
      
      <guid>/post/rsa-padding/</guid>
      <description>&lt;p&gt;在实际应用的RSA算法里面，消息都必须经过填充以后才会被加密，以拒绝同态攻击。在RFC8017的&lt;a href=&#34;https://tools.ietf.org/html/rfc8017#section-7.2.1&#34;&gt;7.2.1&lt;/a&gt;节，详细介绍了RSA的加密过程。本文稍微简化了加密流程，以求更能直观解释填充攻击的原理。想要了解RSA算法更多细节的同学，请参阅RFC8017文档。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Polly Cracker破解</title>
      <link>/post/polly-cracker-attack/</link>
      <pubDate>Wed, 05 Aug 2020 13:35:37 +0200</pubDate>
      
      <guid>/post/polly-cracker-attack/</guid>
      <description>在前文介绍了非对称加密系统Polly Cracker，就像naive RSA一样，它也不是一个安全的加密系统。例如，在已知一对明文密文\((m, c)\),攻击者可以构造出来一个新的明文密文对\((m+m&#39;, c+m&#39;)\)，因为\((c + m&#39;)(\sigma) = c(\sigma) + m&#39; = m + m&#39;\)。但本文将要讨论的问题要比这个严重的多：攻击者可以通过构造特殊的密文，直接解出来Polly Cracker的密钥。</description>
    </item>
    
    <item>
      <title>Polly Cracker加密系统</title>
      <link>/post/polly-cracker/</link>
      <pubDate>Fri, 31 Jul 2020 21:24:29 +0200</pubDate>
      
      <guid>/post/polly-cracker/</guid>
      <description>&lt;p&gt;现代加密系统的安全性建立在计算数学难题之上，比如RSA基于质因数分解，DH基于DLog计算。本文介绍的加密系统Polly Cracker则是基于组合多项式求解。为了更好地理解Polly Cracker的原理，首先来熟悉一下需要用到的数学知识。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Vigenere密码破解</title>
      <link>/post/vigenere-attack/</link>
      <pubDate>Sat, 11 Jul 2020 11:23:56 +0200</pubDate>
      
      <guid>/post/vigenere-attack/</guid>
      <description>&lt;p&gt;在介绍Vigenere密码之前，先介绍一个更为简单的密码系统：凯撒密码(Caeser Cipher)。据称，当年凯撒曾用这种方法和手下的将领进行通信，传达指挥命令。凯撒密码是一种替换加密技术，即明文中所有字母都在字母表上向后或者向前偏移一个固定的距离，被替换成密文。当这个距离是3的时候，即称作凯撒密码。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
