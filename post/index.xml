<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zlog</title>
    <link>/post/</link>
    <description>Recent content in Posts on Zlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Jul 2022 14:04:31 +0200</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>以太坊的状态存储</title>
      <link>/post/state-in-ethereum/</link>
      <pubDate>Fri, 08 Jul 2022 14:04:31 +0200</pubDate>
      
      <guid>/post/state-in-ethereum/</guid>
      <description>以太坊是由交易驱动的状态机，一笔正确有效的交易将以太坊的当前状态变更为下一个状态。区块是交易集合的基本单位，一个有效的区块包含多笔交易。当一个有效区块被加入到以太坊的区块链中，也就意味着该区块包含的所有交易完成了一次对以太坊的状态更新。即，区块触发了以太坊的状态变更。
以太坊使用Trie结构(comes from reTrieve)去存储所有的状态变化，Trie是一种前缀树，实现了key-value的存储结构，通过key可以很方便地取出(retrieve)value。Trie的具体结构是另外一件有意思的事情，有机会另写一篇小文解释。本文主要描述，基于Trie实现的四种以太坊存储结构。
以太坊定义了四种树形存储结构
 State Tree Receipt Tree Transaction Tree Storage Tree  State Tree又被称作世界状态树(World State Tree)，整个以太坊网络仅有一颗状态树，状态树的根哈希相当于目前整个以太坊的状态快照，每一个区块头均保存着当前区块高度下的状态根。每一次以太坊世界的状态更新，都会引起状态根(state root)的变化。 由于每一次区块的增加，都会引起状态树的变化，因此需要一种数据结构来完成方便高效的插入、更新、删除等操作。以太坊采用了Merkle-Patricia-Trie(MPT)树来实现状态树,一个以太坊账户地址就是一把key，而对应的value包含了该账户的余额、nounce、合约代码（如果key是合约地址）以及合约账户的存储（storage root）。
可以这样理解状态树：所有的以太坊账户(key)以及它们的状态(value)构成了一棵MPT，状态根就是对作为整体的以太坊的一次快照。因为每一个区块头均包含一个状态根，所以称区块触发了以太坊的状态变更。
Receipt Tree和Transaction Tree均是和交易相关的树形结构，一个区块体所包含的所有交易构成一棵Transaction Tree(通常是Merkle Tree)，其根哈希(transaction root)保存在区块头，作为该区块内所有交易内容的存在性证明。而Receipt Tree负责保存一个区块内所有交易的执行结果，包括了消耗的燃气，记录的日志，交易结束后的状态等等，其根哈希(receipt root)同样保存在区块头，作为该区块内所有交易的执行证明。
每一个区块都记录了一棵独立的Transaction Tree和Receipt Tree，区块一旦入链，其root将不再改变；而所有的区块共同维护着一个State Tree，随着区块链的增长，其root在每个区块高度上记录着以太坊的状态变化。
另外一棵隐藏在状态树下的Storage Tree是用来记录智能合约的存储状态的变化，每一个合约地址在状态树上的value中均有一个storage root，记录着合约在每次交易之后的存储变化。合约存储的数据保存在以太坊的数据库中，不同的以太坊实现可以采用不同的数据库技术。例如，Go-Ethereum使用leveldb，而Parity使用了rocksdb。通过查询隐藏在State Root里面的storage root，每一个智能合约的每一次对数据库内容的修改都能得到所有节点的确认，实现了以太坊的分布式存储。
在这里我们简单描述了，四种树形结构帮助实现了以太坊的去中心化共识，在存储、执行(Transaction, Receipt)和状态三个层次上，Trie都能够用来对信息的确认和回溯。而具体的树形结构和对其的各种操作方法并非本文的重点，但是它们对于以太坊的开发者至关重要，值得学习。</description>
    </item>
    
    <item>
      <title>旅行的意義</title>
      <link>/post/love-traveling/</link>
      <pubDate>Thu, 16 Jun 2022 17:35:45 +0200</pubDate>
      
      <guid>/post/love-traveling/</guid>
      <description></description>
    </item>
    
    <item>
      <title>浅谈三种跨链技术</title>
      <link>/post/cross-chain/</link>
      <pubDate>Wed, 15 Jun 2022 18:51:25 +0200</pubDate>
      
      <guid>/post/cross-chain/</guid>
      <description></description>
    </item>
    
    <item>
      <title>RUN</title>
      <link>/post/run/</link>
      <pubDate>Fri, 08 Apr 2022 01:01:34 +0200</pubDate>
      
      <guid>/post/run/</guid>
      <description>&lt;p&gt;跑步对于我来说，是最舒服的独处方式。跑起来很简单，左脚迈过右脚，右脚迈过左脚，一步一步往前。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一個防身藥方的三味藥</title>
      <link>/post/commencement/</link>
      <pubDate>Wed, 30 Mar 2022 20:17:00 +0200</pubDate>
      
      <guid>/post/commencement/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;一篇抄自維基文庫收錄的&lt;a href=&#34;https://zh.m.wikisource.org/zh-hant/%E4%B8%80%E5%80%8B%E9%98%B2%E8%BA%AB%E8%97%A5%E6%96%B9%E7%9A%84%E4%B8%89%E5%91%B3%E8%97%A5&#34;&gt;演講稿&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>FastBFT</title>
      <link>/post/fastbft/</link>
      <pubDate>Sat, 09 Oct 2021 11:30:23 +0200</pubDate>
      
      <guid>/post/fastbft/</guid>
      <description>&lt;p&gt;一篇论文小笔记，而已。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《民权初步》序</title>
      <link>/post/rro-intro/</link>
      <pubDate>Fri, 06 Aug 2021 11:31:19 +0200</pubDate>
      
      <guid>/post/rro-intro/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近在读《罗伯特议事规则》，瞥见孙中山因此书作序言，便手录在此。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>共识系列|拜占庭将军问题</title>
      <link>/post/byz/</link>
      <pubDate>Mon, 05 Jul 2021 20:52:56 +0200</pubDate>
      
      <guid>/post/byz/</guid>
      <description>&lt;p&gt;得益于无数聪明的头脑，对于区块链行业发展的思考和探索正在朝着两个方向迈进，有人在想象并期待着区块链之上能够出现更多安全而且可靠的DAPP，为数字资产的流动赋予无与伦比的自由和速度；也有人在深刻思索着区块链之下的共识机制，审视着人类协作活动的最基础性原理，以求得一条最为直接而且可信的通往共识之路，并改变人类组织的管理模式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>可变难度下的超轻验证原理</title>
      <link>/post/flyclient02/</link>
      <pubDate>Thu, 06 May 2021 22:58:30 +0200</pubDate>
      
      <guid>/post/flyclient02/</guid>
      <description>&lt;p&gt;在前一篇文章，我们详细解释了基于不变难度的超轻节点如何验证区块的有效性以及其验证结果正确概率的模型。这个模型的前提是基于理想状态设定的，能够帮助读者更容易理解超轻节点的工作流程和其背后的数学原理，但在真实的区块链行业，基于PoW的共识算法会随着参与网络竞争的节点数量和运算能力改变而周期性调整难度目标。这意味着，节点必须检查区块的PoW是否满足难度调整函数。&lt;/p&gt;
&lt;p&gt;在本篇文章，我们将首先介绍中本聪为比特币网络设置的难度调整函数，然后用更形式化的方法为读者解释难度调整函数，最后说明在可变难度下超轻节点如何检查区块的PoW。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>超轻节点如何验证PoW有效性</title>
      <link>/post/flyclient01/</link>
      <pubDate>Fri, 12 Mar 2021 22:28:03 +0200</pubDate>
      
      <guid>/post/flyclient01/</guid>
      <description>&lt;p&gt;为了验证交易的合法性，加密货币例如比特币和以太坊，要求节点必须验证区块链的有效性。节点在接入加密货币网络之初，需要花费数小时以及相当大的磁盘空间来下载、验证和存储所有区块。然而一些客户端由于缺乏必要的资源(带宽、存储)，无法独立验证交易，必须依赖全节点。比特币和以太坊均提供了一种名为SPV客户端的方法，SPV客户端仅仅验证和保存所有的区块头。然而，仅仅保存区块头的存储要求也是随着链长的增长而线性增长。至2021年1月为止，以太坊网络的SPV客户端需要存储的区块头数据已经逼近 6 GB。对于资源更受限的 IoT 设备，其存储上限可能都无法达到上述要求。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RLP编解码规则</title>
      <link>/post/rlp/</link>
      <pubDate>Wed, 10 Mar 2021 22:15:27 +0200</pubDate>
      
      <guid>/post/rlp/</guid>
      <description>&lt;p&gt;递归式长度前缀(Recursive Length Prefix)是以太坊用来对数据进行序列化和反序列的编码规则，这里是参考以太网维基[^1]的一篇小小笔记。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>梅克尔山脉——跨链交易中超轻验证的可能性</title>
      <link>/post/mmr-intro/</link>
      <pubDate>Fri, 05 Feb 2021 22:11:59 +0200</pubDate>
      
      <guid>/post/mmr-intro/</guid>
      <description>&lt;p&gt;梅克尔树被发明的初衷，是为了给大量的数据做一个简短的声明，即使数据被拆成若干个部分保存，也能通过梅克尔树来判断最后组合起来的整体的正确性。因为如果某一部分数据被修改或者遭受损坏，最后就无法得到与之前相同的根哈希。&lt;/p&gt;
&lt;p&gt;不难理解，能够这么做的前提是已知所有的数据，才能使用梅克尔树。但在区块链领域，每一种链一直都在产生新的区块。2012年，比特币核心开发者Peter Todd遇到了类似的问题。在为一堆不停增长的数据求根哈希的时候，他需要找到一种办法来方便快捷地向梅克尔树上新增叶子节点，同时保证求取根的过程尽量简单，于是他发明了梅克尔山脉(Merkle Mountain Ranges, )——一种专为不停增长的数据整体求根哈希的结构。本文将详细介绍梅克尔山脉及其应用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Merkle Tree之二</title>
      <link>/post/merkle-tree02/</link>
      <pubDate>Thu, 14 Jan 2021 22:08:24 +0200</pubDate>
      
      <guid>/post/merkle-tree02/</guid>
      <description>&lt;p&gt;在前一篇文章里，笔者介绍了如何使用梅克尔树给一个区块里的所有交易生成一个哈希，作为树根存储在区块头，以及解释了当交易数量不足时，为什么需要引入的冗余信息来「凑齐」一棵完整二叉树，最后说明了比特币网络如何避免由于冗余信息所引起的潜在双花攻击。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Merkle Tree之一</title>
      <link>/post/merkle-tree01/</link>
      <pubDate>Mon, 11 Jan 2021 17:33:21 +0800</pubDate>
      
      <guid>/post/merkle-tree01/</guid>
      <description>&lt;p&gt;双花攻击是任何一种数字货币都需要解决的问题，如果是真实的物理货币，天然可以避免双花攻击，因为攻击者口袋里的钱币花出去了，就真实地离开了自己。而数字货币，其实是一串特殊的字符串，可以无限复制，如何使被复制的信息不再有效，就成了解决双花问题的关键。即使是中国央行推出的数字人民币系统DC/EP，也在一定程度上面临双花问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>回来</title>
      <link>/post/back-to-china2020/</link>
      <pubDate>Fri, 13 Nov 2020 11:09:25 +0100</pubDate>
      
      <guid>/post/back-to-china2020/</guid>
      <description>汉莎航班LH728在十二点左右的时候抵达停机坪，乘务在广播里面请求大家先坐在原位，不要起身拿行李。稍后一会儿，动作干练、全身防备的防疫工作者进入机舱，将具有发热、咽痛或者咳嗽的几名乘客优先带离，去做核酸检测，剩下的人按照座位号码依次离开。我在第二十排，很快就离开飞机，前往大厅领取「采样知情同意书」。在去采样实验室的路上，可见好几处红外测温仪。同样因为前额头发比较长，我还被拦下，要求把刘海撩上去，重新测。在做鼻拭子采样的时候，护士动作很温柔，较之前在法兰克福的体验，要好很多。这一次，两只鼻孔都需要采样。过程是这样的：将口罩摘下露出鼻孔，但要遮住嘴唇。脸向上自然昂起，护士姐姐用一根长长的棉签伸进鼻孔，在抵达一个较深的位置后，她提醒我自然呼吸十秒钟，同时她也缓缓旋转棉签，尽可能多地采集样本。
做完核酸检测以后，排队等待通关。疫情期间，即使是中国籍旅客，也必须走人工核验通道。海关小姊姊看了一眼我的护照，询问隔离结束以后的行程安排。如果需要离开上海的话，根据目的地的不同，在上海的隔离要求也不一样。像是江浙皖地区的人员可是实行3+11隔离政策，即上海隔离3天，然后转运回当地继续隔离11天。而我选择直接隔离满14天以后，继续在上海完成我的实习。
通关以后，来到旋转托盘处等我的行李被传送出来。在这同一个托盘上，有来自两个航班的行李，德国的LH728和国航的CA6228。大家从天涯的尽头回来，一路艰辛，此刻等待的片段，算是难得的轻松。因为我使用了一个艳红色的行李套，所以很远就能一眼看到我的旅行箱子。拿到旅行箱子，就可以彻底离开海关处了。不用多说，离开海关前，还必须做最后一次行李安检。出来以后，很快遇到工作人员询问，是本地还是离开上海？
因为我的目的地是上海松江，现在需要走到松江区设置在浦东机场的防疫小组。在工作人员的提醒下，我完成了最后一次信息提交，获得了一张机场入境旅客二维码，内容无外乎证件号码，上海居住地址，联系方式等等。这二维码将被打印出来，贴在护照的背面，以备查验。
上海各个区在机场的地铁入口附近都设立了工作区域，其实就是连成一排的桌子，后面坐着几位工作人员，负责登记旅客信息，收集护照，安排隔离酒店，然后联系大巴将旅客转运至酒店隔离。据说，酒店的分配应该是完全随机的，我们并不能提任何要求，只能等待宣布结果。而我在登记信息的时候，小哥询问隔离是希望住200块一晚，还是400块一晚？我毫不犹豫选择了前者，此趟归途，花费不菲，还是尽量节约吧。稍后赶到的另外一个男生，选择了400档，他应该是同我一样从德国回来。
登记完成以后，时间大致一点半左右。浦东机场这一套检测分流的过程，操作起来颇为迅速，几乎没有遇到排队的现象。而我目及的所有工作人员，统统着统一的防疫服，佩戴N95口罩与护目眼镜，带医用胶手套，几乎没有裸露在外的皮肤。所有人除了嗓音，身形的不同，其它的区别统统都被抹去。有个瞬间，我甚至觉得，他们像是星球大战里面的克隆人大军。另外，在这完全相同的着装之下，似乎人人都实现了某种平等。那种用来区分科层的服饰，被隐藏在洁白的防护服之下。在我们看来，对方是科长或者普通职员，已没有任何不同。
在等待约二个小时以后，终于通知我们可以登上大巴前往松江了。这一趟总共就八人去松江隔离，其中四人和我一样住在泗泾人才公寓。这应该区政府为了这片创新园区所设立的廉价酒店，是一座公共设施，价格也相当便宜。每天餐食60块，每天房费200块，隔离14天总共花费3640+120块核酸检测 = 3760块，比我之前预计的要少很多。
因为睡得早，今晚夜半醒来，发现浦东机场似乎成为了上海这次疫情的爆发中心。看到了社交网络里面乌泱泱挤在一起等待核酸检测的人们，心中难过，这件事情远远还没有结束。</description>
    </item>
    
    <item>
      <title>作用域与链接性</title>
      <link>/post/scope-linkage/</link>
      <pubDate>Thu, 29 Oct 2020 23:14:15 +0100</pubDate>
      
      <guid>/post/scope-linkage/</guid>
      <description>&lt;p&gt;这是一篇关于&lt;code&gt;C++&lt;/code&gt;变量的作用域与链接性的笔记，整理了各种相关概念以备疏忘。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>现代密码系统的安全概念与形式</title>
      <link>/post/formal-security/</link>
      <pubDate>Sun, 18 Oct 2020 21:24:07 +0200</pubDate>
      
      <guid>/post/formal-security/</guid>
      <description>&lt;p&gt;在不久之前，密码学还不能被称作一门学科，顶多是一种手艺。在古典密码学时代，密码系统的安全仅仅取决于设计者和攻击者的创造力和技巧，人们并不能证明一种密码系统的安全性究竟几何？也没有对密码系统的诸多元件有清晰而明确的定义。&lt;/p&gt;
&lt;p&gt;密码学真正成为一门系统而逻辑严密的学科，源自二战时，交战双方终于意识到通信的安全性对于战局的决定性影响力。德国佬的Enigma机器曾使盟军头痛不已，直到图灵和波兰数学家的合作才终于破译德军的军事情报信息。由战争带来的对于安全通信的需求，在战后的冷战时代未曾消减，密码学的理论研究终于大放异彩。今天，几乎所有关于密码理论的基本概念都源自那个令人不安的时代。&lt;/p&gt;
&lt;p&gt;本篇小文将介绍现代密码系统的几种安全模型，及其相互关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CBC之伪造密文</title>
      <link>/post/cbc-fake-cipher/</link>
      <pubDate>Tue, 06 Oct 2020 11:49:35 +0200</pubDate>
      
      <guid>/post/cbc-fake-cipher/</guid>
      <description>&lt;p&gt;之前的&lt;a href=&#34;https://www.zlog-in/post/cbc-padding/&#34;&gt;小文&lt;/a&gt;详细介绍了如何利用&lt;code&gt;Oracle&lt;/code&gt;实现对CBC的填充攻击，从而解出明文内容。此篇小文将解释如何利用这一对明文密文&lt;code&gt;(m,c)&lt;/code&gt;，在不知道密钥的情况下，构造一个对合法的明文密钥&lt;code&gt;(M,C)&lt;/code&gt;。这样，攻击者便能在通信双方未能察觉之下修改通信内容，以达到自己的目的。跟前文一样，此文还是以二个消息块为例。有了前文的基础，此文直接进入主题。对CBC不了解或者不够熟悉的读者，请先翻阅前文。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线性分析 FEAL4</title>
      <link>/post/feal4/</link>
      <pubDate>Thu, 01 Oct 2020 21:03:03 +0200</pubDate>
      
      <guid>/post/feal4/</guid>
      <description>&lt;p&gt;FEAL4(Fast data Encryption Algorithm)由日本密码学家清水明宏和宫口庄司于1987年在日本电信电话株式会社(NTT)任职期间提出，作为一个针对DES的替代加密方案。相比较DES被设计成硬件电路的思路，FEAL4可由纯软件实现，得益于较少的加密轮数(4轮)，其执行速度相当快。本文首先介绍FEAL4以及DES所使用的Feistel加密结构，根据FEAL4所使用的F函数，分析F输入及输出之间的线性关系。然后解释，如何利用该线性关系配合较少的明文密文对，攻击者可以快速破解密钥。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CBC填充攻击</title>
      <link>/post/cbc-padding/</link>
      <pubDate>Sat, 19 Sep 2020 20:53:58 +0200</pubDate>
      
      <guid>/post/cbc-padding/</guid>
      <description>&lt;p&gt;CBC(Cipher Block Chaining)是一种块加密，所谓块，就是一段固定长度的数据。明文，也就是待加密的数据，被分割成若干个块，然后分别加密每一个块。如果最后一个块未被填满，则需要额外的数据填充其中，然后加密。在本文首先介绍CBC加密系统的工作流程，然后就其采用的填充标准&lt;a href=&#34;https://tools.ietf.org/html/rfc2315#section-10.3&#34;&gt;PKCS#7&lt;/a&gt;详细说明一种攻击方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SOCKS5协议</title>
      <link>/post/socks5/</link>
      <pubDate>Tue, 08 Sep 2020 12:56:50 +0200</pubDate>
      
      <guid>/post/socks5/</guid>
      <description>&lt;p&gt;最近看了一下&lt;a href=&#34;https://tools.ietf.org/html/rfc1928&#34;&gt;&lt;code&gt;SOCKS5&lt;/code&gt;&lt;/a&gt;协议，一个小巧方便的代理协议，这里是一些笔记。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大数幂运算</title>
      <link>/post/exponential-large-number/</link>
      <pubDate>Tue, 25 Aug 2020 22:25:43 +0200</pubDate>
      
      <guid>/post/exponential-large-number/</guid>
      <description>幂运算(Exponentiation)又称指数运算，写作\(c= m^e \)，即\(c\)等于\(e\)个\(m\)相乘。当\(m\)或者\(e\)的数值不大的时候，可以通过重复的乘法运算来获得\(c\)。当\(m\)和\(e\)都是一个大数的时候，比如说512位长。尽管有了计算机，显然对\(m\)重复\(e\)次乘法运算的效率不高。那么该怎样快速进行大数幂运算呢？</description>
    </item>
    
    <item>
      <title>RSA填充攻击</title>
      <link>/post/rsa-padding/</link>
      <pubDate>Thu, 20 Aug 2020 10:09:33 +0200</pubDate>
      
      <guid>/post/rsa-padding/</guid>
      <description>&lt;p&gt;在实际应用的RSA算法里面，消息都必须经过填充以后才会被加密，以拒绝同态攻击。在RFC8017的&lt;a href=&#34;https://tools.ietf.org/html/rfc8017#section-7.2.1&#34;&gt;7.2.1&lt;/a&gt;节，详细介绍了RSA的加密过程。本文稍微简化了加密流程，以求更能直观解释填充攻击的原理。想要了解RSA算法更多细节的同学，请参阅RFC8017文档。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Polly Cracker破解</title>
      <link>/post/polly-cracker-attack/</link>
      <pubDate>Wed, 05 Aug 2020 13:35:37 +0200</pubDate>
      
      <guid>/post/polly-cracker-attack/</guid>
      <description>在前文介绍了非对称加密系统Polly Cracker，就像naive RSA一样，它也不是一个安全的加密系统。例如，在已知一对明文密文\((m, c)\),攻击者可以构造出来一个新的明文密文对\((m+m&#39;, c+m&#39;)\)，因为\((c + m&#39;)(\sigma) = c(\sigma) + m&#39; = m + m&#39;\)。但本文将要讨论的问题要比这个严重的多：攻击者可以通过构造特殊的密文，直接解出来Polly Cracker的密钥。</description>
    </item>
    
    <item>
      <title>Polly Cracker加密系统</title>
      <link>/post/polly-cracker/</link>
      <pubDate>Fri, 31 Jul 2020 21:24:29 +0200</pubDate>
      
      <guid>/post/polly-cracker/</guid>
      <description>&lt;p&gt;现代加密系统的安全性建立在计算数学难题之上，比如RSA基于质因数分解，DH基于DLog计算。本文介绍的加密系统Polly Cracker则是基于组合多项式求解。为了更好地理解Polly Cracker的原理，首先来熟悉一下需要用到的数学知识。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Vigenere密码破解</title>
      <link>/post/vigenere-attack/</link>
      <pubDate>Sat, 11 Jul 2020 11:23:56 +0200</pubDate>
      
      <guid>/post/vigenere-attack/</guid>
      <description>&lt;p&gt;在介绍Vigenere密码之前，先介绍一个更为简单的密码系统：凯撒密码(Caeser Cipher)。据称，当年凯撒曾用这种方法和手下的将领进行通信，传达指挥命令。凯撒密码是一种替换加密技术，即明文中所有字母都在字母表上向后或者向前偏移一个固定的距离，被替换成密文。当这个距离是3的时候，即称作凯撒密码。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
